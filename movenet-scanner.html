<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Webcam Body Scanner (MediaPipe Pose)</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 0; background: #111; color: #eee; display: flex; gap: 16px; align-items: flex-start; padding: 16px; }
    #container { position: relative; width: 720px; max-width: calc(100vw - 200px); }
    video { display:block; width:100%; border-radius: 8px; transform: scaleX(-1); /* mirror for user-friendly view */ }
    canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none; transform: scaleX(-1); } 
    #controls { min-width: 200px; max-width: 320px; }
    .panel { background:#151515; padding:12px; border-radius:8px; margin-bottom:12px; box-shadow: 0 6px 18px rgba(0,0,0,0.6); }
    label { display:block; margin:6px 0; font-size:14px; }
    input[type=range] { width:100%; }
    button { background:#0ea5a4; border:none; color:#062323; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:600; }
    button.secondary { background:#2b6f9e; color:white; }
    small { color:#9aa; }
  </style>
</head>
<body>
  <div id="container" class="panel">
    <video id="video" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="controls">
    <div class="panel">
      <h3 style="margin:0 0 8px 0">Scanner Controls</h3>
      <label>Model complexity
        <select id="complexity">
          <option value="0">Light (fast)</option>
          <option value="1">Default</option>
          <option value="2" selected>Heavy (more accurate)</option>
        </select>
      </label>

      <label>Min detection confidence: <span id="minDetectVal">0.30</span></label>
      <input id="minDetect" type="range" min="0" max="1" step="0.05" value="0.3">

      <label>Smooth landmarks: <input id="smoothing" type="checkbox" checked></label>
      <label>Show all landmarks (ignore visibility): <input id="showAll" type="checkbox"></label>

      <label>Dot size: <input id="dotSize" type="range" min="2" max="12" value="6"></label>

      <label>Show skeleton: <input id="showSkeleton" type="checkbox" checked></label>

      <div style="margin-top:10px; display:flex; gap:8px;">
        <button id="startBtn">Start Camera</button>
        <button id="stopBtn" class="secondary">Stop</button>
      </div>
    </div>

    <div class="panel">
      <h4 style="margin:0 0 8px 0">Export</h4>
      <small>Save the latest detected landmark coordinates as JSON.</small>
      <div style="margin-top:8px; display:flex; gap:8px;">
        <button id="saveJson">Save JSON</button>
        <button id="clearData" class="secondary">Clear Data</button>
      </div>
      <p style="margin-top:8px;"><small id="status">Status: idle</small></p>
      <div style="margin-top:8px;">
        <h5 style="margin:6px 0">Measured thickness (px)</h5>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;">
          <div>Left arm: <strong id="leftArmTh">-</strong></div>
          <div>Right arm: <strong id="rightArmTh">-</strong></div>
          <div>Left leg: <strong id="leftLegTh">-</strong></div>
          <div>Right leg: <strong id="rightLegTh">-</strong></div>
          <div>Torso: <strong id="torsoTh">-</strong></div>
          <div>Multiplier: <strong id="thMultiplierVal">0.12</strong></div>
        </div>
        <label style="display:block;margin-top:8px">Thickness multiplier: <input id="thicknessMultiplier" type="range" min="0.02" max="0.4" step="0.01" value="0.12"></label>
      </div>
    </div>

    <div class="panel">
      <h4 style="margin:0 0 8px 0">Privacy</h4>
      <small>All processing is local — frames & landmarks are not uploaded anywhere by this page. Use responsibly.</small>
    </div>
  </div>

  <!-- MediaPipe & utils (served from jsdelivr CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
    // Globals
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    let camera = null;
    let pose = null;
    let lastResults = null;
    let collectedFrames = []; // store exported frames (optional)
  let currentThicknesses = { leftArm: null, rightArm: null, leftLeg: null, rightLeg: null, torso: null };
    const statusEl = document.getElementById('status');

    // UI elements
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const saveJsonBtn = document.getElementById('saveJson');
    const clearDataBtn = document.getElementById('clearData');
    const complexitySelect = document.getElementById('complexity');
    const minDetect = document.getElementById('minDetect');
    const minDetectVal = document.getElementById('minDetectVal');
    const smoothing = document.getElementById('smoothing');
  const showAll = document.getElementById('showAll');
  const dotSize = document.getElementById('dotSize');
  const showSkeleton = document.getElementById('showSkeleton');
  const thicknessMultiplier = document.getElementById('thicknessMultiplier');
  const thMultiplierVal = document.getElementById('thMultiplierVal');
  const leftArmTh = document.getElementById('leftArmTh');
  const rightArmTh = document.getElementById('rightArmTh');
  const leftLegTh = document.getElementById('leftLegTh');
  const rightLegTh = document.getElementById('rightLegTh');
  const torsoTh = document.getElementById('torsoTh');

    // Resize canvas to video size
    function resizeCanvasToVideo() {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }

    // Draw landmarks (dots) and optionally skeleton
    function drawResults(results) {
      if (!results || !results.poseLandmarks) return;
      resizeCanvasToVideo();
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Optionally draw skeleton using MediaPipe drawing utils
      if (showSkeleton.checked) {
        window.drawConnectors(ctx, results.poseLandmarks, window.POSE_CONNECTIONS, {color: '#00FFAA', lineWidth: 2});
      }

      // Draw torso fill (simple quad using shoulders and hips)
      function drawTorso(fillColor = '#33FFAA44', strokeColor = '#1b7f5f88') {
        // landmark order: left_shoulder(11), right_shoulder(12), right_hip(24), left_hip(23)
        const idxs = [11,12,24,23];
        const pts = idxs.map(i => results.poseLandmarks[i]).filter(Boolean);
        if (pts.length < 4) return;
        const cpts = pts.map(p => ({x: p.x * canvas.width, y: p.y * canvas.height, v: p.visibility ?? 1}));
        const anyVisible = cpts.some(p => p.v > 0.05);
        if (!anyVisible && !(showAll && showAll.checked)) return;

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(cpts[0].x, cpts[0].y);
        for (let i = 1; i < cpts.length; i++) ctx.lineTo(cpts[i].x, cpts[i].y);
        ctx.closePath();
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.strokeStyle = strokeColor;
        ctx.stroke();
        ctx.restore();
      }

      function computeTorsoThickness() {
        // use shoulder and hip horizontal distances as proxy for torso breadth
        const Ls = results.poseLandmarks[11];
        const Rs = results.poseLandmarks[12];
        const Lh = results.poseLandmarks[23];
        const Rh = results.poseLandmarks[24];
        if (!Ls || !Rs || !Lh || !Rh) return null;
        const sdx = (Ls.x - Rs.x) * canvas.width;
        const hdx = (Lh.x - Rh.x) * canvas.width;
        const shoulderDist = Math.abs(sdx);
        const hipDist = Math.abs(hdx);
        const avgWidth = (shoulderDist + hipDist) / 2;
        const mult = (thicknessMultiplier && thicknessMultiplier.value) ? Number(thicknessMultiplier.value) : 0.12;
        const torsoBase = Math.max(6, Math.min(200, Math.round(avgWidth * mult)));
        return torsoBase;
      }

      // Draw limb outlines (arms & legs) using widened stroked paths so limbs look like filled shapes
      // Uses typical MediaPipe Pose landmark indices: shoulders/elbows/wrists and hips/knees/ankles
      function toCanvas(p) {
        return { x: p.x * canvas.width, y: p.y * canvas.height, v: p.visibility ?? 1 };
      }

      function drawLimbOutline(idxs, fillColor = '#00FFAA88', strokeColor = '#004B3388') {
        const pts = idxs.map(i => results.poseLandmarks[i]).filter(Boolean);
        if (pts.length < 2) return;
        const cpts = pts.map(toCanvas);
        // require at least one visible point unless showAll
        const anyVisible = cpts.some(p => p.v > 0.05);
        if (!anyVisible && !(showAll && showAll.checked)) return;

        // compute limb width proportional to the total pixel length of the limb
        let length = 0;
        for (let i = 1; i < cpts.length; i++) {
          const dx = cpts[i].x - cpts[i-1].x;
          const dy = cpts[i].y - cpts[i-1].y;
          length += Math.hypot(dx, dy);
        }
          // compute thickness using multiplier from UI
          const mult = (thicknessMultiplier && thicknessMultiplier.value) ? Number(thicknessMultiplier.value) : 0.12;
          const base = Math.max(4, Math.min(120, Math.round(length * mult)));

        ctx.save();
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        // Outline (outer stroke)
        ctx.beginPath();
        ctx.moveTo(cpts[0].x, cpts[0].y);
        for (let i = 1; i < cpts.length; i++) ctx.lineTo(cpts[i].x, cpts[i].y);
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = base + 10;
        ctx.stroke();

        // Inner fill stroke
        ctx.beginPath();
        ctx.moveTo(cpts[0].x, cpts[0].y);
        for (let i = 1; i < cpts.length; i++) ctx.lineTo(cpts[i].x, cpts[i].y);
        ctx.strokeStyle = fillColor;
        ctx.lineWidth = base;
        ctx.stroke();

        ctx.restore();
        return base;
      }

  // Compute thickness values and update UI
  const torsoBase = computeTorsoThickness();
  currentThicknesses.torso = torsoBase;
  if (torsoTh) torsoTh.textContent = torsoBase === null ? '-' : torsoBase;

  // Shade torso first so limbs draw on top
  drawTorso('#FFD7A644', '#8a5f12aa');

  // Left arm: 11 (left_shoulder), 13 (left_elbow), 15 (left_wrist)
  const leftArmBase = drawLimbOutline([11,13,15], '#FFD23Fcc', '#8a5f12cc');
  currentThicknesses.leftArm = leftArmBase;
  if (leftArmTh) leftArmTh.textContent = leftArmBase === undefined ? '-' : leftArmBase;
      // Right arm: 12,14,16
  const rightArmBase = drawLimbOutline([12,14,16], '#FFD23Fcc', '#8a5f12cc');
  currentThicknesses.rightArm = rightArmBase;
  if (rightArmTh) rightArmTh.textContent = rightArmBase === undefined ? '-' : rightArmBase;
      // Left leg: 23 (left_hip),25 (left_knee),27 (left_ankle)
  const leftLegBase = drawLimbOutline([23,25,27], '#7FD6FFcc', '#24687Acc');
  currentThicknesses.leftLeg = leftLegBase;
  if (leftLegTh) leftLegTh.textContent = leftLegBase === undefined ? '-' : leftLegBase;
      // Right leg: 24,26,28
  const rightLegBase = drawLimbOutline([24,26,28], '#7FD6FFcc', '#24687Acc');
  currentThicknesses.rightLeg = rightLegBase;
  if (rightLegTh) rightLegTh.textContent = rightLegBase === undefined ? '-' : rightLegBase;

      // Draw dots for each landmark
      const r = Number(dotSize.value);
      ctx.fillStyle = '#FFD23F';
      for (let i = 0; i < results.poseLandmarks.length; i++) {
        const lm = results.poseLandmarks[i];
        // lm.x and lm.y are normalized [0..1], where origin is top-left
        const x = lm.x * canvas.width;
        const y = lm.y * canvas.height;
        // confidence/visibility might be in lm.visibility
        const visible = (lm.visibility === undefined) ? 1 : lm.visibility;
        // If "showAll" is checked, draw all landmarks regardless of visibility.
        // Otherwise only draw landmarks above a modest visibility threshold so arms/legs are still captured.
        const visibilityThreshold = 0.05; // low threshold to include limbs with lower confidence
        if (showAll && showAll.checked) {
          ctx.beginPath();
          ctx.arc(x, y, r * (0.9 + Math.max(0, visible)*0.2), 0, Math.PI*2);
          ctx.fill();
        } else if (visible > visibilityThreshold) {
          ctx.beginPath();
          ctx.arc(x, y, r * (0.9 + visible*0.2), 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // Called by MediaPipe pose on each frame's results
    function onResults(results) {
      lastResults = results;
      statusEl.textContent = 'Status: got landmarks';
      drawResults(results);

      // store a reduced version for export if needed
      // We keep normalized coordinates and visibility
      if (results.poseLandmarks) {
        const frameStamp = {
          timestamp: Date.now(),
          landmarks: results.poseLandmarks.map(l => ({x: l.x, y: l.y, z: l.z ?? 0, visibility: l.visibility ?? 1}))
        };
        // Optional: keep last 300 frames to avoid memory explosion
        collectedFrames.push(frameStamp);
        if (collectedFrames.length > 300) collectedFrames.shift();
      }
    }

    async function startCamera() {
      // Initialize MediaPipe Pose
      if (!pose) {
        pose = new window.Pose({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
        });
        pose.setOptions({
          modelComplexity: Number(complexitySelect.value),
          smoothLandmarks: smoothing.checked,
          minDetectionConfidence: Number(minDetect.value),
          minTrackingConfidence: 0.5
        });
        pose.onResults(onResults);
      } else {
        // update options on restart
        pose.setOptions({
          modelComplexity: Number(complexitySelect.value),
          smoothLandmarks: smoothing.checked,
          minDetectionConfidence: Number(minDetect.value),
        });
      }

      // Start camera using MediaPipe Camera utility
      camera = new window.Camera(video, {
        onFrame: async () => {
          await pose.send({image: video});
        },
        width: 1280,
        height: 720
      });

      try {
        camera.start();
        statusEl.textContent = 'Status: camera started (waiting for frames)';
      } catch (err) {
        console.error('Camera start failed:', err);
        statusEl.textContent = 'Status: camera failed — check permissions';
      }
    }

    function stopCamera() {
      if (camera) {
        try {
          camera.stop();
        } catch (e) { /* ignore */ }
        camera = null;
      }
      statusEl.textContent = 'Status: stopped';
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    // Save JSON of the last frame or collected frames
    function saveJson() {
      if (!lastResults || !lastResults.poseLandmarks) {
        alert('No landmarks detected yet — move into view of the camera and press Save again.');
        return;
      }
      const payload = {
        when: (new Date()).toISOString(),
        width: video.videoWidth || null,
        height: video.videoHeight || null,
        landmarks: lastResults.poseLandmarks.map((lm, i) => ({index:i, x: lm.x, y: lm.y, z: lm.z ?? 0, visibility: lm.visibility ?? 1})),
        thicknesses: currentThicknesses
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `pose_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      statusEl.textContent = 'Status: JSON saved';
    }

    // Export all collected frames
    function saveAllCollected() {
      if (collectedFrames.length === 0) {
        alert('No frames collected.');
        return;
      }
      const payload = {when: new Date().toISOString(), frames: collectedFrames};
      const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `pose_frames_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      statusEl.textContent = 'Status: collected frames exported';
    }

    // Wire up UI
    startBtn.addEventListener('click', () => {
      startCamera();
    });
    stopBtn.addEventListener('click', () => {
      stopCamera();
    });
    saveJsonBtn.addEventListener('click', () => {
      // Choose: save only last frame or all frames based on Ctrl key
      if (window.event && window.event.shiftKey) {
        saveAllCollected();
      } else {
        saveJson();
      }
    });
    clearDataBtn.addEventListener('click', () => {
      collectedFrames = [];
      statusEl.textContent = 'Status: cleared collected frames';
    });

    minDetect.addEventListener('input', () => {
      minDetectVal.textContent = minDetect.value;
      if (pose) pose.setOptions({minDetectionConfidence: Number(minDetect.value)});
    });
    complexitySelect.addEventListener('change', () => {
      if (pose) pose.setOptions({modelComplexity: Number(complexitySelect.value)});
    });
    smoothing.addEventListener('change', () => {
      if (pose) pose.setOptions({smoothLandmarks: smoothing.checked});
    });
    if (thicknessMultiplier) {
      thMultiplierVal.textContent = thicknessMultiplier.value;
      thicknessMultiplier.addEventListener('input', () => {
        thMultiplierVal.textContent = thicknessMultiplier.value;
      });
    }

    // When the video metadata is ready (dimensions), resize canvas
    video.addEventListener('loadedmetadata', resizeCanvasToVideo);

    // Stop camera when page is unloaded
    window.addEventListener('beforeunload', () => {
      stopCamera();
    });

    // Auto-start attempt: useful on desktop when allowed
    // Comment this out if you prefer to tap Start manually
    //startCamera();
  </script>
</body>
</html>
